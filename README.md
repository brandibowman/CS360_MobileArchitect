# CS360_MobileArchitect

# Briefly summarize the requirements and goals of the app you developed. What user needs was this app designed to address?
The Weight Tracker app was developed to meet the user’s needs for managing and monitoring their weight goals effectively. The app allows users to set a goal weight, record their daily weight, and track their progress over time through a clear, easy-to-navigate history screen. Users also have the flexibility to delete specific entries as needed. To provide motivation and timely updates, the app sends an SMS notification to the user when they achieve their goal weight, ensuring they stay informed and encouraged throughout their journey.

# What screens and features were necessary to support user needs and produce a user-centered UI for the app? How did your UI designs keep users in mind? Why were your designs successful?

The app was designed to be simple, intuitive, and user-friendly while meeting all the needs of someone tracking their weight and goals. The first essential screen is the Login screen, where users can either create an account or log in. Once logged in, they’re taken to the Home screen, where they can set their goal weight and record their daily weight. If they click the “Record Weight” button, they’re taken to a new screen where the current date is automatically filled in, and they can enter their weight. The date field is flexible, allowing users to select today’s date or any past date using a calendar picker, but future dates are restricted to keep the data accurate. The Data History screen gives users a clean list of all their recorded weight entries. Each entry has its own “Delete” button, so users can easily remove specific records. At the bottom of this screen, there’s an “Add” button that redirects back to the Record Weight screen, giving users a quick way to add new entries. The Settings screen provides two key features: SMS permissions and personalized weight goal options. Users can save their phone number and dynamically enable or disable SMS notifications. For weight goals, users can select “Weight Loss”, where an SMS is sent when they hit or fall below their goal, “Weight Gain”, where an SMS triggers when they reach or exceed their goal, or “Maintain Weight”, where an SMS alerts users if their weight falls outside a buffer zone. When “Maintain Weight” is selected, the app dynamically reveals the buffer zone input and a “Save Goal” button, allowing users to set boundaries for staying within their target range. 

To ensure a clean and focused experience, I kept the UI straightforward and user-centered. I used a bottom navigation bar for easy access to all main screens so users don’t get lost. The app’s color palette features dark and light purple for its primary and secondary colors, while the Record Weight button stands out in teal to highlight its importance. The settings page uses dynamic features like gray-out buttons when options are disabled, and the buffer zone field only becomes visible when needed, reducing unnecessary clutter on the screen. Throughout the app, I included toast messages to keep users informed—whether they successfully saved a goal, deleted an entry, or encountered an error. This combination of thoughtful navigation, responsive design, and clear feedback made the app easy to use while delivering on its goal of helping users track their weight progress effectively.

# How did you approach the process of coding your app? What techniques or strategies did you use? How could those techniques or strategies be applied in the future?
I built the app with a modular approach to keep everything organized and easy to manage. For example, the GoalChecker handles the logic for checking a user’s recorded weight against their goals. It pulls the goal weight, goal type, and buffer zone from the SharedPrefsUtils file and, if the conditions are met, sends an SMS notification to the user. The SharedPrefsUtils file acts as a central place to store and retrieve important user data like goal weights, phone numbers, goal types, and buffer zones. This keeps everything consistent and accessible across the app. For storing weight entries and user credentials, I used the DatabaseHelper, which securely manages usernames, passwords, and recorded weights. By keeping each part of the app focused on one job, I made the code cleaner, easier to understand, and simpler to update in the future. This modular approach reduced redundancy and ensures that if changes are needed later—like adding a new feature or improving existing ones—it can be done without affecting other parts of the app.

# How did you test to ensure your code was functional? Why is this process important, and what did it reveal?
I ensured the functionality of my app through incremental testing throughout the development process. Initially, I tested the core features, such as screen navigation and bottom navigation interactions, to confirm they worked as intended. After implementing key functionalities like adding weight entries, deleting weight entries, and updating goal weights, I validated that data was saved and retrieved correctly. When integrating SMS notifications, I tested to ensure messages were sent appropriately based on weight goals (e.g., weight loss, weight gain, and maintenance). Throughout development, I performed regression testing to confirm that new code did not interfere with existing features. For instance, while adding the "Maintain Weight" goal, testing revealed conflicts with weight gain SMS notifications, which I resolved by refining the logic for goal checks. This process was crucial because it ensured the app remained stable, functional, and user-friendly while new features were integrated. It revealed areas where logic needed clarification or where overlapping conditions caused conflicts, helping me produce a more reliable app. 

# Consider the full app design and development process from initial planning to finalization. Where did you have to innovate to overcome a challenge?
One of the biggest challenges I faced was implementing and testing the Maintain Weight feature with its buffer zone, while also making sure it worked smoothly alongside the existing Weight Loss and Weight Gain goals. I could not figure out what was wrong and almost gave up on incorporating a Maintain Weight goal. After some time, I finally noticed the conditions for sending SMS notifications were overlapping, which caused the app to behave incorrectly. To fix this, I carefully analyzed the logic and restructured it to create clear, separate conditions for each goal type. This included accurately calculating the buffer zone to ensure notifications were only sent when needed. Another tricky area was managing user credentials and making sure that each user's data was kept separate. Initially, data from previous users would sometimes appear for the current user, which was a major issue. I solved this by refining the database queries to properly filter and display only the data for the logged-in user. By approaching these problems with incremental testing and careful refactoring, I was able to resolve them without breaking other features in the app. This process taught me the importance of staying organized, testing frequently, and tackling challenges step by step to deliver a functional and reliable solution.

# In what specific component of your mobile app were you particularly successful in demonstrating your knowledge, skills, and experience?
I’m especially proud of the work I did on the GoalChecker logic for SMS notifications. This part of the app required me to handle different scenarios for weight goals, like Weight Loss, Weight Gain, and Maintain Weight, while keeping the code clean and easy to follow. I had to carefully calculate buffer zones for the Maintain Weight goal to ensure the app could compare the user’s current weight accurately to their target range. Integrating SmsManager was another highlight, as I made sure notifications were sent at just the right moment for each goal type. It took some problem-solving to get everything working together smoothly, but in the end, the logic was solid, and the notifications worked exactly as intended. This experience really showed me how important it is to balance logical thinking with clear, maintainable code to create features that feel seamless for the user.
